import { NextRequest, NextResponse } from 'next/server'
import { PDFDocument } from 'pdf-lib'
import { db } from '@/lib/db'

export async function POST(request: NextRequest) {
  try {
    const formData = await request.formData()
    const file = formData.get('file') as File

    if (!file) {
      return NextResponse.json({ error: 'No file provided' }, { status: 400 })
    }

    if (file.type !== 'application/pdf') {
      return NextResponse.json({ error: 'File must be a PDF' }, { status: 400 })
    }

    // Check file size (50MB limit)
    if (file.size > 50 * 1024 * 1024) {
      return NextResponse.json({ error: 'File too large' }, { status: 400 })
    }

    // Get file buffer
    const bytes = await file.arrayBuffer()
    const buffer = Buffer.from(bytes)

    // Load PDF document
    const pdfDoc = await PDFDocument.load(buffer)
    const pageCount = pdfDoc.getPageCount()

    // Extract text from PDF (simplified version)
    // In a real implementation, you would use a proper PDF text extraction library
    const textContent = []
    for (let i = 0; i < pageCount; i++) {
      const page = pdfDoc.getPage(i)
      // This is a simplified version - in production, use a proper PDF text extraction library
      textContent.push(`Page ${i + 1} content would be extracted here`)
    }

    // Create a simple DOCX structure (simplified)
    // In a real implementation, you would use a proper DOCX generation library
    const docxContent = createSimpleDocxContent(textContent, file.name)

    // Log analytics
    try {
      await db.analytics.create({
        data: {
          toolName: 'pdf-to-word',
          count: 1
        }
      })

      await db.fileProcess.create({
        data: {
          originalName: file.name,
          fileSize: file.size,
          fileType: file.type,
          processedType: 'application/vnd.openxmlformats-officedocument.wordprocessingml.document',
          status: 'completed',
          completedAt: new Date()
        }
      })
    } catch (error) {
      console.error('Failed to log analytics:', error)
    }

    // Return the processed document
    return new NextResponse(docxContent, {
      headers: {
        'Content-Type': 'application/vnd.openxmlformats-officedocument.wordprocessingml.document',
        'Content-Disposition': `attachment; filename="converted_${file.name.replace('.pdf', '.docx')}"`
      }
    })

  } catch (error) {
    console.error('PDF to Word conversion error:', error)
    
    // Log error
    try {
      await db.fileProcess.create({
        data: {
          originalName: file?.name || 'unknown',
          fileSize: file?.size || 0,
          fileType: file?.type || 'unknown',
          status: 'failed',
          errorMessage: error instanceof Error ? error.message : 'Unknown error'
        }
      })
    } catch (logError) {
      console.error('Failed to log error:', logError)
    }

    return NextResponse.json(
      { error: 'Failed to convert PDF to Word' },
      { status: 500 }
    )
  }
}

// Helper function to create a simple DOCX content
// This is a simplified version - in production, use a proper DOCX library
function createSimpleDocxContent(textContent: string[], originalFilename: string): Buffer {
  // This is a very basic HTML representation that Word can open
  // In production, you would use a proper DOCX generation library like docx
  const htmlContent = `
<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Converted from ${originalFilename}</title>
  <style>
    body { font-family: Arial, sans-serif; margin: 40px; }
    h1 { color: #333; border-bottom: 2px solid #333; }
    .page { margin-bottom: 30px; page-break-after: always; }
    .page:last-child { page-break-after: auto; }
  </style>
</head>
<body>
  <h1>Converted from ${originalFilename}</h1>
  <p><em>Converted using FileHub PDF to Word Converter</em></p>
  <hr>
  
  ${textContent.map((content, index) => `
  <div class="page">
    <h2>Page ${index + 1}</h2>
    <p>${content}</p>
  </div>
  `).join('')}
  
  <hr>
  <p><small>Generated by FileHub - Free File Tools</small></p>
</body>
</html>
  `

  return Buffer.from(htmlContent, 'utf-8')
}